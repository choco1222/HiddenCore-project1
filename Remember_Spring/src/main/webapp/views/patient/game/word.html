<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìˆ¨ì€ ë‚±ë§ ì°¾ê¸°</title>
    <link rel="stylesheet" href="../css/word.css" />
</head>
<body>
    <div class="container">
        <!-- ë‚œì´ë„ ì„ íƒ í™”ë©´ -->
        <div class="difficulty-screen" id="difficultyScreen">
            <div class="difficulty-card">
                <h1>ìˆ¨ì€ ë‚±ë§ ì°¾ê¸°</h1>
                <p>ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn easy" onclick="startGame('easy')">
                        ğŸŸ¢ í•˜ (7x7, 5ë‹¨ì–´, 15ì´ˆ)
                    </button>
                    <button class="difficulty-btn medium" onclick="startGame('medium')">
                        ğŸŸ¡ ì¤‘ (8x8, 7ë‹¨ì–´, 20ì´ˆ)
                    </button>
                    <button class="difficulty-btn hard" onclick="startGame('hard')">
                        ğŸ”´ ìƒ (10x10, 9ë‹¨ì–´, 30ì´ˆ)
                    </button>
                </div>
            </div>
        </div>

        <!-- ê²Œì„ í™”ë©´ -->
        <div class="game-screen" id="gameScreen">
            <div class="game-header">
                <h1>ìˆ¨ì€ ë‚±ë§ ì°¾ê¸°</h1>
                <div class="header-buttons">
                    <button class="replay-btn" onclick="replayGame()">ğŸ”„ ë‹¤ì‹œí•˜ê¸°</button>
                    <button class="reset-btn" onclick="resetGame()">ì²˜ìŒìœ¼ë¡œ</button>
                </div>
            </div>
            
            <div class="game-stats">
                <div class="stat-box">
                    <div class="stat-label">ë‚¨ì€ ì‹œê°„</div>
                    <div class="stat-value timer" id="timer">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">ì ìˆ˜</div>
                    <div class="stat-value" id="score">0</div>
                </div>
            </div>
            
            <div class="game-content">
                <div>
                    <div class="grid-container" id="gridContainer"></div>
                </div>
                <div class="word-list">
                    <h2>ì°¾ì„ ë‹¨ì–´</h2>
                    <div class="word-items" id="wordList"></div>
                    <div id="completionMessage"></div>
                    <div class="progress-info">
                        <p><strong>ì§„í–‰ë¥ :</strong> <span id="progress">0 / 0</span></p>
                        <p class="hint" id="hintText"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ê²Œì„ ìƒíƒœ
        let difficulty = null;
        let grid = [];
        let words = [];
        let wordListDisplay = [];
        let foundWords = [];
        let selectedCells = [];
        let isSelecting = false;
        let timeLeft = 0;
        let timerInterval = null;
        let score = 0;
        let gameOver = false;

        // ë‚œì´ë„ë³„ ì„¤ì •
        const difficultySettings = {
            easy: { 
                size: 7, 
                wordCount: 5, 
                words: ['ë‘ë¦¬ì•ˆ', 'ì²­í¬ë„', 'ìˆ˜ë°•', 'ë¸”ë£¨ë² ë¦¬', 'ë”¸ê¸°'],
                wordListChosungCount: 0,
                timeLimit: 15,
                baseScore: 100
            },
            medium: { 
                size: 8, 
                wordCount: 7, 
                words: ['ê°€ì¡±ì—¬í–‰', 'ë‚˜ë“¤ì´', 'ê·€í–¥ê¸¸', 'ë°°ìš°ì', 'ê°€ì‹œë²„ì‹œ', 'ê°€ì •', 'ì¥ì¸ì–´ë¥¸'],
                wordListChosungCount: 0,
                timeLimit: 20,
                baseScore: 100
            },
            hard: { 
                size: 10, 
                wordCount: 9, 
                words: ['ì¼€ì´í¬', 'ìƒì¼íŒŒí‹°', 'ê²°í˜¼ì‹', 'ì£¼ì¸ê³µ', 'ì„ ë¬¼', 'ì²­ì²©ì¥', 'ì¶•í•˜ì—°', 'ì£¼ìµœì', 'ì¶•í•˜í•˜ë‹¤'],
                wordListChosungCount: 5,
                timeLimit: 30,
                baseScore: 100
            }
        };

        // í•œê¸€ ì´ˆì„± ì¶”ì¶œ
        function getChosung(char) {
            const chosungList = ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
            const code = char.charCodeAt(0) - 44032;
            if (code < 0 || code > 11171) return char;
            return chosungList[Math.floor(code / 588)];
        }

        // ë‹¨ì–´ë¥¼ ì´ˆì„±ìœ¼ë¡œ ë³€í™˜
        function wordToChosung(word) {
            return word.split('').map(char => getChosung(char)).join('');
        }
        
        // ë‹¨ì–´ ì¤‘ í•œ ê¸€ìë§Œ ì´ˆì„±ìœ¼ë¡œ ë³€í™˜ (ë³´ê¸° ëª©ë¡ ì „ìš©)
        function wordToPartialChosung(word) {
            const index = Math.floor(Math.random() * word.length);
            return word
                .split('')
                .map((char, i) => i === index ? getChosung(char) : char)
                .join('');
        }

        // íƒ€ì´ë¨¸ ì‹œì‘
        function startTimer() {
            const settings = difficultySettings[difficulty];
            timeLeft = settings.timeLimit;
            updateTimerDisplay();
            
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                if (timeLeft <= 0) {
                    endGame(false);
                }
            }, 1000);
        }

        // íƒ€ì´ë¨¸ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateTimerDisplay() {
            const timerElement = document.getElementById('timer');
            timerElement.textContent = timeLeft + 'ì´ˆ';
            
            const settings = difficultySettings[difficulty];
            const halfTime = settings.timeLimit / 2;
            const quarterTime = settings.timeLimit / 4;
            
            timerElement.classList.remove('warning', 'danger');
            if (timeLeft <= quarterTime) {
                timerElement.classList.add('danger');
            } else if (timeLeft <= halfTime) {
                timerElement.classList.add('warning');
            }
        }

        // ì ìˆ˜ ê³„ì‚°
        function calculateScore() {
            const settings = difficultySettings[difficulty];
            const wordsFound = foundWords.length;
            const totalWords = words.length;
            
            // ëª¨ë“  ë‹¨ì–´ë¥¼ ì°¾ì•˜ì„ ê²½ìš°
            if (wordsFound === totalWords) {
                // ì‹œê°„ ë‚´ì— ì™„ë£Œí•œ ê²½ìš° 100ì 
                if (timeLeft > 0) {
                    return 100;
                }
                // ì‹œê°„ ì´ˆê³¼ í›„ ì™„ë£Œí•œ ê²½ìš°ë„ 100ì 
                return 100;
            }
            
            // ì¼ë¶€ë§Œ ì°¾ì€ ê²½ìš°
            const basePoints = Math.floor((wordsFound / totalWords) * settings.baseScore);
            return basePoints;
        }

        // ì ìˆ˜ ì—…ë°ì´íŠ¸
        function updateScore() {
            score = calculateScore();
            document.getElementById('score').textContent = score + 'ì ';
        }

        // ê²Œì„ ì¢…ë£Œ
        function endGame(completed) {
            gameOver = true;
            clearInterval(timerInterval);
            
            // ëª¨ë“  ë‹¨ì–´ë¥¼ ì°¾ì€ ê²½ìš° ë‚¨ì€ ì‹œê°„ê³¼ ìƒê´€ì—†ì´ 100ì 
            if (completed) {
                score = 100;
            } else {
                score = calculateScore();
            }
            
            document.getElementById('score').textContent = score + 'ì ';
            
            const completionMessage = document.getElementById('completionMessage');
            
            if (completed && timeLeft > 0) {
                completionMessage.innerHTML = `
                    <div class="completion-message">
                        <p>ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ëª¨ë“  ë‹¨ì–´ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!</p>
                        <div class="score-display">ì ìˆ˜: ${score}ì </div>
                        <p style="margin-top: 10px;">ë‚¨ì€ ì‹œê°„: ${timeLeft}ì´ˆ</p>
                    </div>
                `;
            } else if (completed && timeLeft <= 0) {
                completionMessage.innerHTML = `
                    <div class="completion-message">
                        <p>ğŸ‰ ëª¨ë“  ë‹¨ì–´ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!</p>
                        <div class="score-display">ì ìˆ˜: ${score}ì </div>
                    </div>
                `;
            } else {
                completionMessage.innerHTML = `
                    <div class="game-over-message">
                        <p>â° ì‹œê°„ ì¢…ë£Œ!</p>
                        <div class="score-display">ì ìˆ˜: ${score}ì </div>
                        <p style="margin-top: 10px;">ì°¾ì€ ë‹¨ì–´: ${foundWords.length} / ${words.length}</p>
                    </div>
                `;
            }
        }

        // ê·¸ë¦¬ë“œ ìƒì„±
        function createGrid(size, wordList) {
            const newGrid = Array(size).fill(null).map(() => 
                Array(size).fill(null).map(() => ({ letter: '', isWord: false, wordIndex: -1 }))
            );
            
            const directions = [
                [0, 1],   // ê°€ë¡œ
                [1, 0],   // ì„¸ë¡œ
                [1, 1],   // ëŒ€ê°ì„  â†˜
                [-1, 1],  // ëŒ€ê°ì„  â†—
            ];

            const placedWords = [];

            // ê° ë‹¨ì–´ë¥¼ ê·¸ë¦¬ë“œì— ë°°ì¹˜
            wordList.forEach((word, wordIndex) => {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 100) {
                    const direction = directions[Math.floor(Math.random() * directions.length)];
                    const row = Math.floor(Math.random() * size);
                    const col = Math.floor(Math.random() * size);
                    
                    if (canPlaceWord(newGrid, word, row, col, direction, size)) {
                        placeWord(newGrid, word, row, col, direction, wordIndex);
                        placedWords.push(word);
                        placed = true;
                    }
                    attempts++;
                }
            });

            // ë¹ˆ ì¹¸ì„ ëœë¤ í•œê¸€ë¡œ ì±„ìš°ê¸°
            const hangul = 'ê°€ë‚˜ë‹¤ë¼ë§ˆë°”ì‚¬ì•„ìì°¨ì¹´íƒ€íŒŒí•˜ê±°ë„ˆë”ëŸ¬ë¨¸ë²„ì„œì–´ì €ì²˜ì»¤í„°í¼í—ˆê³ ë…¸ë„ë¡œëª¨ë³´ì†Œì˜¤ì¡°ì´ˆì½”í† í¬í˜¸';
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (!newGrid[i][j].letter) {
                        newGrid[i][j].letter = hangul[Math.floor(Math.random() * hangul.length)];
                    }
                }
            }

            return { grid: newGrid, words: placedWords };
        }

        function canPlaceWord(grid, word, row, col, direction, size) {
            const [dx, dy] = direction;
            
            for (let i = 0; i < word.length; i++) {
                const newRow = row + (dx * i);
                const newCol = col + (dy * i);
                
                if (newRow < 0 || newRow >= size || newCol < 0 || newCol >= size) {
                    return false;
                }
                
                if (grid[newRow][newCol].letter && grid[newRow][newCol].letter !== word[i]) {
                    return false;
                }
            }
            
            return true;
        }

        function placeWord(grid, word, row, col, direction, wordIndex) {
            const [dx, dy] = direction;
            
            for (let i = 0; i < word.length; i++) {
                const newRow = row + (dx * i);
                const newCol = col + (dy * i);
                
                grid[newRow][newCol] = {
                    letter: word[i],
                    fullLetter: word[i],
                    isWord: true,
                    wordIndex: wordIndex
                };
            }
        }

        // ê²Œì„ ì‹œì‘
        function startGame(level) {
            difficulty = level;
            const settings = difficultySettings[level];
            const { grid: newGrid, words: placedWords } = createGrid(settings.size, settings.words);
            grid = newGrid;
            words = placedWords;
            
            // ë³´ê¸° ë‹¨ì–´ ëª©ë¡ ìƒì„±
            const numChosungWords = settings.wordListChosungCount;
            const chosungWordIndices = [];
            
            if (numChosungWords > 0) {
                const availableIndices = placedWords.map((_, idx) => idx);
                for (let i = 0; i < numChosungWords && i < availableIndices.length; i++) {
                    const randomIndex = Math.floor(Math.random() * availableIndices.length);
                    chosungWordIndices.push(availableIndices[randomIndex]);
                    availableIndices.splice(randomIndex, 1);
                }
            }
            
            wordListDisplay = placedWords.map((word, idx) => ({
                original: word,
                display: chosungWordIndices.includes(idx) ? wordToPartialChosung(word) : word,
                isChosung: chosungWordIndices.includes(idx)
            }));
            
            foundWords = [];
            selectedCells = [];
            score = 0;
            gameOver = false;
            
            renderGame();
            startTimer();
        }

        // ê²Œì„ ë Œë”ë§
        function renderGame() {
            document.getElementById('difficultyScreen').style.display = 'none';
            document.getElementById('gameScreen').classList.add('active');
            
            // ê·¸ë¦¬ë“œ ë Œë”ë§
            const gridContainer = document.getElementById('gridContainer');
            gridContainer.innerHTML = '';
            
            grid.forEach((row, rowIndex) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'grid-row';
                
                row.forEach((cell, colIndex) => {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'grid-cell';
                    cellDiv.textContent = cell.letter;
                    cellDiv.dataset.row = rowIndex;
                    cellDiv.dataset.col = colIndex;
                    
                    cellDiv.addEventListener('mousedown', handleCellMouseDown);
                    cellDiv.addEventListener('mouseenter', handleCellMouseEnter);
                    cellDiv.addEventListener('mouseup', handleCellMouseUp);
                    
                    rowDiv.appendChild(cellDiv);
                });
                
                gridContainer.appendChild(rowDiv);
            });

            // ì „ì—­ mouseup ì´ë²¤íŠ¸
            document.addEventListener('mouseup', () => {
                if (isSelecting) {
                    isSelecting = false;
                    checkWord();
                }
            });
            
            // ë‹¨ì–´ ëª©ë¡ ë Œë”ë§
            renderWordList();
            updateScore();
        }

        // ë‹¨ì–´ ëª©ë¡ ë Œë”ë§
        function renderWordList() {
            const wordList = document.getElementById('wordList');
            wordList.innerHTML = '';
            
            wordListDisplay.forEach(wordInfo => {
                const wordDiv = document.createElement('div');
                wordDiv.className = 'word-item';
                if (foundWords.includes(wordInfo.original)) {
                    wordDiv.classList.add('found');
                } else if (wordInfo.isChosung) {
                    wordDiv.classList.add('chosung');
                }
                wordDiv.textContent = wordInfo.display;
                wordList.appendChild(wordDiv);
            });
            
            // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
            document.getElementById('progress').textContent = `${foundWords.length} / ${words.length}`;
            
            // íŒíŠ¸ í…ìŠ¤íŠ¸
            const hintText = document.getElementById('hintText');
            if (difficulty === 'hard') {
                hintText.textContent = 'ğŸ’¡ íŒŒë€ìƒ‰ ë°°ê²½: ì´ˆì„± íŒíŠ¸';
            } else {
                hintText.textContent = '';
            }
        }

        // ì…€ í´ë¦­ ì²˜ë¦¬
        function handleCellMouseDown(e) {
            if (gameOver) return;
            isSelecting = true;
            selectedCells = [{ row: parseInt(e.target.dataset.row), col: parseInt(e.target.dataset.col) }];
            updateCellStyles();
        }

        function handleCellMouseEnter(e) {
            if (!isSelecting || gameOver) return;
            
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            const lastCell = selectedCells[selectedCells.length - 1];
            
            if (!lastCell || lastCell.row !== row || lastCell.col !== col) {
                // ì´ë¯¸ ì„ íƒëœ ì…€ì´ë©´ ë¬´ì‹œ
                if (selectedCells.some(cell => cell.row === row && cell.col === col)) {
                    return;
                }
                
                // ì²« ë²ˆì§¸ ì…€ì´ë©´ ë¬´ì¡°ê±´ ì¶”ê°€
                if (selectedCells.length === 1) {
                    selectedCells.push({ row, col });
                    updateCellStyles();
                    return;
                }
                
                // ë‘ ë²ˆì§¸ ì…€ ì´í›„ë¶€í„°ëŠ” ë°©í–¥ ì²´í¬
                const firstCell = selectedCells[0];
                const secondCell = selectedCells[1];
                
                const initialDx = Math.sign(secondCell.row - firstCell.row);
                const initialDy = Math.sign(secondCell.col - firstCell.col);
                
                const currentDx = Math.sign(row - firstCell.row);
                const currentDy = Math.sign(col - firstCell.col);
                
                if (currentDx === initialDx && currentDy === initialDy) {
                    const expectedRow = lastCell.row + initialDx;
                    const expectedCol = lastCell.col + initialDy;
                    
                    if (row === expectedRow && col === expectedCol) {
                        selectedCells.push({ row, col });
                        updateCellStyles();
                    }
                }
            }
        }

        function handleCellMouseUp(e) {
            if (gameOver) return;
            isSelecting = false;
            checkWord();
        }

        // ì…€ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
        function updateCellStyles() {
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('selected', 'found');
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                if (selectedCells.some(c => c.row === row && c.col === col)) {
                    cell.classList.add('selected');
                } else if (isFoundCell(row, col)) {
                    cell.classList.add('found');
                }
            });
        }

        function isFoundCell(row, col) {
            const cell = grid[row][col];
            if (!cell.isWord) return false;
            const wordIndex = cell.wordIndex;
            return foundWords.includes(words[wordIndex]);
        }

        // ë‹¨ì–´ ì²´í¬
        function checkWord() {
            if (selectedCells.length < 2 || gameOver) {
                selectedCells = [];
                updateCellStyles();
                return;
            }

            const selectedWord = selectedCells.map(cell => {
                const gridCell = grid[cell.row][cell.col];
                return gridCell.fullLetter || gridCell.letter;
            }).join('');
            
            if (words.includes(selectedWord) && !foundWords.includes(selectedWord)) {
                foundWords.push(selectedWord);
                renderWordList();
                updateScore();
                
                // ëª¨ë“  ë‹¨ì–´ë¥¼ ì°¾ì•˜ëŠ”ì§€ í™•ì¸
                if (foundWords.length === words.length) {
                    endGame(true);
                }
            }
            
            selectedCells = [];
            updateCellStyles();
        }

        // ê²Œì„ ë¦¬ì…‹
        function resetGame() {
            clearInterval(timerInterval);
            difficulty = null;
            grid = [];
            words = [];
            wordListDisplay = [];
            foundWords = [];
            selectedCells = [];
            isSelecting = false;
            score = 0;
            gameOver = false;
            
            document.getElementById('difficultyScreen').style.display = 'flex';
            document.getElementById('gameScreen').classList.remove('active');
        }

        // ê°™ì€ ë‚œì´ë„ë¡œ ë‹¤ì‹œí•˜ê¸°
        function replayGame() {
            const currentDifficulty = difficulty;
            clearInterval(timerInterval);
            foundWords = [];
            selectedCells = [];
            isSelecting = false;
            score = 0;
            gameOver = false;
            
            // ì™„ë£Œ ë©”ì‹œì§€ ì´ˆê¸°í™”
            document.getElementById('completionMessage').innerHTML = '';
            
            // ê°™ì€ ë‚œì´ë„ë¡œ ìƒˆ ê²Œì„ ì‹œì‘
            startGame(currentDifficulty);
        }
    </script>
</body>
</html>